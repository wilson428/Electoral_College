(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* statesByAbbreviation = Import["./data/state_population_reps_evs.wl"]; *)
statesByAbbreviation = CloudGet["https://www.wolframcloud.com/objects/1a4bfb31-d5d4-49e3-9e04-4cf80e1fae1b"];
stateAbbrs = Keys@statesByAbbreviation;
(* We need a list of state abbreviations without DC since it is not factored into allocation -- "Taxation Without Representation!" *)
stateAbbrs50 = Select[stateAbbrs, # != "DC"&];


PriorityHuntingtonHill[stateAbbr_, stateReps_] := 
	1.0 * statesByAbbreviation[stateAbbr]["population_decennial"]["2010"] / Sqrt[stateReps * (stateReps + 1)]


AllocateOne[reps_, priorities_, priorityFunc_:PriorityHuntingtonHill] := (
	topPriority = First[Keys[Reverse[Sort[priorities]]]];
	updatedPriorities = priorities;
	updatedReps = reps;
	updatedReps[topPriority] += 1;
	updatedPriorities[topPriority] = priorityFunc[topPriority, updatedReps[topPriority]];
	{ updatedReps, updatedPriorities }
);

CalculateAllocations[totalBase_:435, min_:1, bonus_:0, priorityFunc_:PriorityHuntingtonHill]:= (
	total = totalBase + 50 * -bonus; (* we need to add the post-facto bonus to the total so that it doesn't count against it *)
	stateReps = AssociationThread[stateAbbrs50, ConstantArray[min, 50]];
	statePriorities = AssociationThread[stateAbbrs50, priorityFunc[#, 1]& /@ stateAbbrs50];
	While[Total@stateReps < total, { stateReps, statePriorities } = AllocateOne[stateReps, statePriorities, priorityFunc]];
	stateReps = stateReps + bonus;
	KeySort@stateReps
);


{ lightOrange, darkOrange, green, purple, lightGray } = { RGBColor["#FFA63B"], RGBColor["#FF703B"], RGBColor["#47C045"], RGBColor["#E165FA"], RGBColor["#DCDCDC"] };


houseOfRepresentatives = AssociationThread[
	stateAbbrs50,
	statesByAbbreviation[#]["representatives"]["2010"]& /@ stateAbbrs50
];


GetDiffs[calculatedReps_] := calculatedReps - houseOfRepresentatives;


MakeRows[calculatedReps_, sortBy_:"alpha", ascendDescend_:-1] := (
	diffs = GetDiffs[calculatedReps];
	stateKeys = Keys@houseOfRepresentatives;
	
	(* now we can sort. This is like a `Switch` statement, but a little easier to read *)
	sortRules = <|
		"alpha" -> If[ascendDescend == -1, Sort@Keys@houseOfRepresentatives, Reverse@Sort@Keys@houseOfRepresentatives],
		"actual" -> If[ascendDescend == -1, Keys[Sort@houseOfRepresentatives], Keys[Reverse@Sort@houseOfRepresentatives]],
		"yours" -> If[ascendDescend == -1, Keys[Sort@calculatedReps], Keys[Reverse@Sort@calculatedReps]],
		"delta" -> If[ascendDescend == -1, Keys[Sort@diffs], Keys[Reverse@Sort@diffs]]
	|>;

	stateNames = sortRules[sortBy];
		
	maxDiff = Max[diffs];
	maxDiff = If[maxDiff == 0, 2, maxDiff];
		
	colorScales = {
		Function[d, White], (* states, always white *)
		Function[d, Blend[Transpose[{{-10, Max[houseOfRepresentatives]}, { White, lightOrange }}], d]], (* actual house, max is 53 *)
		Function[d, Blend[Transpose[{{-10, Max[calculatedReps]}, { White, darkOrange }}], d]], (* user calculations *)
		Function[d, Blend[Transpose[{{-maxDiff, 0, maxDiff}, { green, White, purple }}], d]] (* diffs, green for losing seats, purple for gaining *)	
	};
	
	(* convert the seating data to items for grid, adding header and footer *)	
	dataAssociations = { AssociationThread[stateNames, stateNames], houseOfRepresentatives, calculatedReps, diffs };

	heightCell = 1;
	widthCell = 2;
	
	(* convert each cell to an Item for easier formatting *)
	itemizeCell[{ dataAssociation_, colorScale_ }] := Item[Style[dataAssociation[#], FontSize->12, TextAlignment->Center],
		Background->colorScale[dataAssociation[#]],
		ItemSize->{ widthCell, heightCell },
		Alignment -> Bottom]&
	/@ stateNames;
	
	itemizedRows = Map[
		itemizeCell,
		Transpose[{ dataAssociations, colorScales }]
	];
	
	totals = { "Total", Total@houseOfRepresentatives, Total@calculatedReps, Total@diffs };
	Append[itemizedRows[[#]], Item[totals[[#]], ItemSize->{2 * widthCell, heightCell}]]& /@ Range[4]
)


HorizontalGrid[calculatedReps_, perRow_:13] := (
	rows = MakeRows[calculatedReps];
	(* build rows of grids *)
	headers = Item[#, Alignment -> Right, ItemSize->{4, 1}]& /@ { "state", "actual", "yours", "delta" };
	parts = First@Partition[rows, { 4, UpTo@perRow }];
	headerRows = Map[Flatten, Transpose[{ headers, # }]& /@ parts, {2}];
	Column[Grid[#, Frame -> All, ItemSize->All, Spacings->{0.2, 0.8}]& /@ headerRows, Spacings -> -0.1]
)


MapDiffs[calculatedReps_] := (
	entityDiffs = KeyMap[statesByAbbreviation[#]["entity"]&, GetDiffs[calculatedReps]];
	green = RGBColor["#47C045"];
	purple = RGBColor["#E165FA"];
	max = Max[entityDiffs];
	max = If[max == 0, 2, max];
	
	colorScheme = Function[d, Blend[Transpose[{{-max, 0, max}, { green, White, purple }}], d]];
	
	contentinal = GeoRegionValuePlot[entityDiffs, GeoRange->Entity["Country","UnitedStates"], ImageSize->499, PlotLegends->None, ColorFunction->colorScheme, ColorFunctionScaling -> False];
	ak = GeoRegionValuePlot[entityDiffs, GeoRange->Entity["AdministrativeDivision",{"Alaska","UnitedStates"}], ImageSize->249, PlotLegends->None, ColorFunction->colorScheme, ColorFunctionScaling -> False];
	hi = GeoRegionValuePlot[entityDiffs, GeoRange->Entity["AdministrativeDivision",{"Hawaii","UnitedStates"}], GeoRangePadding -> {Quantity[30,"Kilometers"], Quantity[50,"Kilometers"]}, ImagePadding->{{5,0},{0,0}}, GeoRangePadding -> {Scaled[0], None}, ImageSize->250, PlotLegends->None, ColorFunction->colorScheme, ColorFunctionScaling -> False];
	Column[{
		Row[{
			Column[{
				Row[{ contentinal }, ImageSize->500],
				Row[{ak,hi}, ImageSize->500]
			}],
			BarLegend[{colorScheme, {-max, max}}, LegendMarkerSize->300]
		}]
	}]
)


statePopulations = AssociationThread[
	stateAbbrs50,
	statesByAbbreviation[#]["population_decennial"]["2010"]& /@ stateAbbrs50
];
totalUSPopulation = Total@statePopulations; (* won't count DC or PR since we have no reps *)


PeoplePerRepresentative[allocation_] := (
	perRep = AssociationThread[
		stateAbbrs50,
		Round[statePopulations[#] / allocation[#] * 1.0]& /@ stateAbbrs50
	]
)


VisualizeRepresentation[allocation_, title_:""] := (
	(* data and stats *)	
	total = Total@allocation;
	ideal = Round[totalUSPopulation / total];
	ratio = PeoplePerRepresentative[allocation];
	sd = StandardDeviation[ratio] * 1.0;
	cov = sd / Mean@ratio;
	sdPrint = NumberForm[Round[sd], DigitBlock->3];	
	ratioWithUS = Append[PeoplePerRepresentative[allocation], "US" -> ideal];

	colorScale = ColorData["Rainbow", Rescale[#1, MinMax@ratio]]&;
	colorFunction = Function[v, If[v == ideal, Yellow, colorScale[v]]];		
	
	sorted = Sort@ratioWithUS;
		
	(* bar chart *)	
	chartWidth = 900;
	chartHeight = 300;
	chartAspect = chartHeight / chartWidth;
	
	allocationWithUS = Append[allocation, "US" -> "N/A"];
		
	plotLabels = {
		{ Style[title, FontSize->24, Bold] },
		{ Style[ToString@total <> " Seats", FontSize->20] },
		{ Style["Target: " <> ToString@NumberForm[ideal, DigitBlock -> 3] <> " people per representative", FontSize->14] },
		{ Style["Standard Deviation: " <> ToString[sdPrint], FontSize->14] },
		{ Item[Style["Coefficient of Variation: " <> ToString@cov, FontSize->14, Bold], Background->LightYellow, ItemSize->{Automatic,2.5}, Alignment->Center, Frame -> True] }
	};
		
	labeledData  = Labeled[sorted[#], Rotate[Style[If[# == "US", "U.S. Average", Row[{Style[#, Bold], ": ", ToString@allocationWithUS[#]}]], If[# == "US", Black, LightGray]], Pi / 2], Top]& /@ Keys@sorted;
	BarChart[
		labeledData,
		ColorFunctionScaling -> False,		
		ColorFunction -> colorFunction,
		ImageSize -> chartWidth,
		AspectRatio -> chartAspect,
		GridLines -> { None, Automatic },
		BarSpacing -> 0,
		PlotRange -> { 0, Automatic },
		PlotRangePadding -> { 0, 0 },
		PlotRange->{ Automatic, Max[sorted] * 1.1 },
		Frame -> True
		(* PlotLabel \[Rule] Grid[plotLabels, Alignment\[Rule]Center] *)
	]
)


visualizeRepresentationInteractive = Manipulate[
	VisualizeRepresentation[CalculateAllocations[total, min, bonus, PriorityHuntingtonHill], title],
	Grid[{
		{ Control[{{title, "My Allocation", "Title:"}}], SpanFromLeft, SpanFromLeft },
		{
			Control[{{ total, 435, "Total Reps:"}, 50, 2000, 1, Appearance -> "Open" }],
			Control[{{ min, 1, "Start With:"}, 0, 40, 1, Appearance -> "Open" }],
			Control[{{ bonus, 0, "Add at End:"}, -5, 20, 1, Appearance -> "Open" }]
		}
	}, Alignment->Center],
	LabelStyle->{ FontSize -> 13 }
];



