(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



Clear["Global`*"];
SetDirectory@NotebookDirectory[];
SetOptions[Notebooks["apportionment.nb"][[1]],AutoGeneratedPackage->Automatic]


(* statesByAbbreviation = Import["./data/state_population_reps_evs.wl"]; *)
statesByAbbreviation = CloudGet["https://www.wolframcloud.com/objects/1a4bfb31-d5d4-49e3-9e04-4cf80e1fae1b"];
stateAbbrs = Keys@statesByAbbreviation;
(* We need a list of state abbreviations without DC since it is not factored into allocation -- "Taxation Without Representation!" *)
stateAbbrs50 = Select[stateAbbrs, # != "DC"&];


priorityHuntingtonHill[stateAbbr_, stateReps_] := 
	1.0 * statesByAbbreviation[stateAbbr]["population_decennial"]["2010"] / Sqrt[stateReps * (stateReps + 1)]


AllocateOne[reps_, priorities_, priorityFunc_:priorityHuntingtonHill] := (
	topPriority = First[Keys[Reverse[Sort[priorities]]]];
	updatedPriorities = priorities;
	updatedReps = reps;
	updatedReps[topPriority] += 1;
	updatedPriorities[topPriority] = priorityFunc[topPriority, updatedReps[topPriority]];
	{ updatedReps, updatedPriorities }
);

calculateAllocations[totalBase_:435, min_:1, bonus_:0, priorityFunc_:priorityHuntingtonHill]:= (
	total = totalBase + 50 * -bonus; (* we need to add the post-facto bonus to the total so that it doesn't count against it *)
	stateReps = AssociationThread[stateAbbrs50, ConstantArray[min, 50]];
	statePriorities = AssociationThread[stateAbbrs50, priorityFunc[#, 1]& /@ stateAbbrs50];
	While[Total@stateReps < total, { stateReps, statePriorities } = AllocateOne[stateReps, statePriorities, priorityFunc]];
	stateReps = stateReps + bonus;
	KeySort@stateReps
);


{ lightOrange, darkOrange, green, purple, lightGray } = { RGBColor["#FFA63B"], RGBColor["#FF703B"], RGBColor["#47C045"], RGBColor["#E165FA"], RGBColor["#DCDCDC"] }


houseOfRepresentatives = AssociationThread[
	stateAbbrs50,
	statesByAbbreviation[#]["representatives"]["2010"]& /@ stateAbbrs50
];


getDiffs[calculatedReps_] := calculatedReps - houseOfRepresentatives;


makeRows[calculatedReps_, sortBy_:"alpha", ascendDescend_:-1] := (
	diffs = getDiffs[calculatedReps];
	stateKeys = Keys@houseOfRepresentatives;
	
	(* now we can sort. This is like a `Switch` statement, but a little easier to read *)
	sortRules = <|
		"alpha" -> If[ascendDescend == -1, Sort@Keys@houseOfRepresentatives, Reverse@Sort@Keys@houseOfRepresentatives],
		"actual" -> If[ascendDescend == -1, Keys[Sort@houseOfRepresentatives], Keys[Reverse@Sort@houseOfRepresentatives]],
		"yours" -> If[ascendDescend == -1, Keys[Sort@calculatedReps], Keys[Reverse@Sort@calculatedReps]],
		"delta" -> If[ascendDescend == -1, Keys[Sort@diffs], Keys[Reverse@Sort@diffs]]
	|>;

	stateNames = sortRules[sortBy];
		
	maxDiff = Max[diffs];
	maxDiff = If[maxDiff == 0, 2, maxDiff];
		
	colorScales = {
		Function[d, White], (* states, always white *)
		Function[d, Blend[Transpose[{{-10, Max[houseOfRepresentatives]}, { White, lightOrange }}], d]], (* actual house, max is 53 *)
		Function[d, Blend[Transpose[{{-10, Max[calculatedReps]}, { White, darkOrange }}], d]], (* user calculations *)
		Function[d, Blend[Transpose[{{-maxDiff, 0, maxDiff}, { green, White, purple }}], d]] (* diffs, green for losing seats, purple for gaining *)	
	};
	
	(* convert the seating data to items for grid, adding header and footer *)	
	dataAssociations = { AssociationThread[stateNames, stateNames], houseOfRepresentatives, calculatedReps, diffs };

	heightCell = 1;
	widthCell = 2;
	
	(* convert each cell to an Item for easier formatting *)
	itemizeCell[{ dataAssociation_, colorScale_ }] := Item[Style[dataAssociation[#], FontSize->12, TextAlignment->Center],
		Background->colorScale[dataAssociation[#]],
		ItemSize->{ widthCell, heightCell },
		Alignment -> Bottom]&
	/@ stateNames;
	
	itemizedRows = Map[
		itemizeCell,
		Transpose[{ dataAssociations, colorScales }]
	];
	
	totals = { "Total", Total@houseOfRepresentatives, Total@calculatedReps, Total@diffs };
	Append[itemizedRows[[#]], Item[totals[[#]], ItemSize->{2 * widthCell, heightCell}]]& /@ Range[4]
)


horizontalGrid[rows_, perRow_:13] := (
	(* build rows of grids *)
	headers = Item[#, Alignment -> Right, ItemSize->{4, 1}]& /@ { "state", "Actual", "Yours", "delta" };
	parts = First@Partition[rows, { 4, UpTo@perRow }];
	headerRows = Map[Flatten, Transpose[{ headers, # }]& /@ parts, {2}];
	Column[Grid[#, Frame -> All, ItemSize->All, Spacings->{0.2, 0.8}]& /@ headerRows, Spacings -> -0.1]
)


mapDiffs[calculatedReps_] := (
	entityDiffs = KeyMap[statesByAbbreviation[#]["entity"]&, getDiffs[calculatedReps]];
	green = RGBColor["#47C045"];
	purple = RGBColor["#E165FA"];
	max = Max[entityDiffs];
	max = If[max == 0, 2, max];
	
	colorScheme = Function[d, Blend[Transpose[{{-max, 0, max}, { green, White, purple }}], d]];
	
	contentinal = GeoRegionValuePlot[entityDiffs, GeoRange->Entity["Country","UnitedStates"], ImageSize->499, PlotLegends->None, ColorFunction->colorScheme, ColorFunctionScaling -> False];
	ak = GeoRegionValuePlot[entityDiffs, GeoRange->Entity["AdministrativeDivision",{"Alaska","UnitedStates"}], ImageSize->249, PlotLegends->None, ColorFunction->colorScheme, ColorFunctionScaling -> False];
	hi = GeoRegionValuePlot[entityDiffs, GeoRange->Entity["AdministrativeDivision",{"Hawaii","UnitedStates"}], GeoRangePadding -> {Quantity[30,"Kilometers"], Quantity[50,"Kilometers"]}, ImagePadding->{{5,0},{0,0}}, GeoRangePadding -> {Scaled[0], None}, ImageSize->250, PlotLegends->None, ColorFunction->colorScheme, ColorFunctionScaling -> False];
	Column[{
		Row[{
			Column[{
				Row[{ contentinal }, ImageSize->500],
				Row[{ak,hi}, ImageSize->500]
			}],
			BarLegend[{colorScheme, {-max, max}}, LegendMarkerSize->300]
		}],
		horizontalGrid[makeRows[calculatedReps], 17]
	}]
)


Manipulate[
	mapDiffs[calculateAllocations[total, min, bonus, priorityHuntingtonHill]],
	{{ total, 435, "Total Reps:"}, 50, 2000, 1, Appearance -> "Open" },
	{{ min, 3, "Start With:"}, 0, 40, 1, Appearance -> "Open" },
	{{ bonus, -2, "Add at End:"}, -5, 20, 1, Appearance -> "Open" },
	LabelStyle->{ FontSize -> 13 }
]


statePopulations = AssociationThread[
	stateAbbrs50,
	statesByAbbreviation[#]["population_decennial"]["2010"]& /@ stateAbbrs50
];
totalUSPopulation = Total@statePopulations; (* won't count DC or PR since we have no reps *)


peoplePerRepresentative[allocation_] := (
	perRep = AssociationThread[
		stateAbbrs50,
		Round[statePopulations[#] / allocation[#] * 1.0]& /@ stateAbbrs50
	]
)





visualizeRepresentation[calculatedReps_, sortBy_:"perRepCalculated", ascendDescend_:-1] := (
	stateKeys = Keys@houseOfRepresentatives;
	
	(* data *)
	perRepHouse = peoplePerRepresentative[AssociationThread[stateKeys, houseOfRepresentatives[#]& /@ stateKeys]];
	perRepCalculated = peoplePerRepresentative[AssociationThread[stateKeys, calculatedReps[#]& /@ stateKeys]];
	
	(* now we can sort. This is like a `Switch` statement, but a little easier to read *)
	sortRules = <|
		"perRepHouse" -> If[ascendDescend == 1, Keys[Sort@perRepHouse], Keys[Reverse@Sort@perRepHouse]],
		"perRepCalculated" -> If[ascendDescend == 1, Keys[Sort@perRepCalculated], Keys[Reverse@Sort@perRepCalculated]]
	|>;			

	stateNames = sortRules[sortBy];
		
	(* BAR CHARTS *)	
	chartWidth = 900;
	chartHeight = 300;
	chartAspect = chartHeight / chartWidth;
		
	makeBarChart = Function[{ assoc, seats, xMax }, (
		labeledData  = Labeled[assoc[#], Rotate[Style[ToString@seats[#] <> " REPS", LightGray], Pi / 2], Top]& /@ Reverse@stateNames;
		BarChart[
			labeledData,
			ColorFunction -> "Rainbow",
			ChartLabels -> stateNames,
			ImageSize -> chartWidth,
			AspectRatio -> chartAspect,
			GridLines -> { None, Automatic },
			Frame -> True,
			FrameTicks -> { 0, 0 },
			FrameLabel -> None,
			BarSpacing -> 0.2,
			PlotRange -> { 0, Automatic },
			PlotRangePadding -> { {0, 0 }, { 0, 1.25 }}
		]
	)];
	
	barChartHouse = makeBarChart[perRepHouse, houseOfRepresentatives, 800000];
	barChartCalculated = makeBarChart[perRepCalculated, calculatedReps, Max[perRepCalculated]];

	(* headers for charts *)	
	covHouse = StandardDeviation[perRepHouse] / Mean@perRepHouse * 1.0;
	labelHouse = Column[{
		Style["People Per Representative", FontSize -> 12],
		Style["Actual Congress", FontSize -> 16, Darker@Red, Bold],
		Grid[{{ Style["Coeff. of Var.: ", FontSize -> 12], Framed[Style[ToString@covHouse, FontSize->14, Bold], Background->Yellow]}}]
	}, Alignment -> Center];

	covCalculated = StandardDeviation[perRepCalculated] / Mean@perRepCalculated * 1.0;
	labelCalculated = Column[{
		Style["People Per Representative", FontSize -> 12],
		Style["Your Recalculation", FontSize -> 16, Darker@Red, Bold],
		Grid[{{ Style["Coeff. of Var.: ", FontSize -> 12], Framed[Style[ToString@covCalculated, FontSize->14, Bold], Background->Yellow]}}]
	}, Alignment -> Center];
	
	columns = {
		labelHouse, barChartHouse, labelCalculated, barChartCalculated
	};

	display = Column[columns, Alignment->Center]
)


visualizeRepresentation[factorInElectors, "perRepHouse", -1]


visualizeCalculation[calculated_] := (		
	sortOn = "alpha";
	ascendDescend = -1;
	rows = {};
		
	sortables = {
		"alpha" -> "Alphabetical",
		"actual" -> "Current Allocation",
		"yours" -> "Calculated Allocations",
		"delta" -> "Difference",
		"perRepHouse" -> "Per Rep: Actual",
		"perRepCalculated" -> "Per Rep: Calculated"	
	};
		
	(*		
	DynamicModule[{sortOn, ascendDescend}, ( 
	
		sortMenu = PopupMenu[Dynamic[sortOn], sortables];
		ascendDescendSelector = RadioButtonBar[Dynamic[ascendDescend], { -1 \[Rule] "Ascending", 1 \[Rule] "Descending" }];
		
		;

		
		
		;
		
		rows = visualizeAllocation[calculated, s, d];
		grid = Grid[
			Prepend[
				rows, 
				{Row[{ sortMenu, ascendDescendSelector }], SpanFromLeft, SpanFromLeft }
			], Frame\[Rule]All, Alignment\[Rule]Top
		]
		
	), DynamicModuleValues \[Rule] True];*)
	
	sortMenu = PopupMenu[Dynamic[sortOn], sortables];
	
	ascendDescendSelector = RadioButtonBar[Dynamic[ascendDescend], { -1 -> "Ascending", 1 -> "Descending" }];
	
	(*
	rows = visualizeAllocation[calculated, Dynamic@sortOn, Dynamic@ascendDescend];
	*);
	rows = Dynamic[sortOn, visAll[calculateAllocations, sortOn, ascendDescend], visualizeAllocation[calculateAllocations, sortOn, ascendDescend]];
	
	Grid[{ sortMenu, ascendDescendSelector }]
)


visualizeCalculation[bigHouse]



